<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Solver Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: white;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .cube-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .cube-display {
            display: grid;
            grid-template-columns: repeat(4, 120px);
            grid-template-rows: repeat(3, 120px);
            gap: 10px;
            margin-bottom: 30px;
        }

        .face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 4px;
            background: #222;
        }

        .top { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .front { grid-column: 2; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }
        .back { grid-column: 4; grid-row: 2; }
        .bottom { grid-column: 2; grid-row: 3; }

        .sticker {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #333;
            text-shadow: 0 0 2px rgba(255,255,255,0.5);
            transition: all 0.3s ease;
        }

        .sticker:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Color scheme */
        .W { background-color: #ffffff; }
        .O { background-color: #ff6500; }
        .G { background-color: #00b04f; }
        .R { background-color: #c41e3a; }
        .B { background-color: #0051ba; }
        .Y { background-color: #ffd500; }

        .controls-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
        }

        .control-section h3 {
            margin-bottom: 15px;
            color: #fff;
            font-size: 1.2em;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .move-btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .move-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
        }

        .move-btn:active {
            transform: translateY(0);
        }

        .action-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            font-size: 14px;
        }

        .primary-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .secondary-btn {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .success-btn {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
        }

        .status-display h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .algorithm-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .algorithm-info h4 {
            color: #f093fb;
            margin-bottom: 10px;
        }

        .move-sequence {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 150px;
            overflow-y: auto;
        }

        .solved-indicator {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .solved {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            animation: pulse 2s infinite;
        }

        .unsolved {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .performance-stats {
            font-size: 12px;
            color: #ccc;
            margin-top: 10px;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .cube-display {
                grid-template-columns: repeat(4, 80px);
                grid-template-rows: repeat(3, 80px);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß© Rubik's Cube Solver</h1>
        <p>Interactive Cube with Working Solver Algorithm</p>
    </div>

    <div class="main-container">
        <div class="cube-container">
            <div class="cube-display" id="cubeDisplay">
                <!-- Cube faces will be generated here -->
            </div>
            
            <div class="solved-indicator" id="solvedIndicator">
                <span id="solvedText">üéØ SOLVED!</span>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-section">
                <h3>üéÆ Manual Controls</h3>
                <div class="button-grid">
                    <button class="move-btn" onclick="makeMove('U')">U</button>
                    <button class="move-btn" onclick="makeMove('U\'')">U'</button>
                    <button class="move-btn" onclick="makeMove('D')">D</button>
                    <button class="move-btn" onclick="makeMove('D\'')">D'</button>
                    <button class="move-btn" onclick="makeMove('L')">L</button>
                    <button class="move-btn" onclick="makeMove('L\'')">L'</button>
                    <button class="move-btn" onclick="makeMove('R')">R</button>
                    <button class="move-btn" onclick="makeMove('R\'')">R'</button>
                    <button class="move-btn" onclick="makeMove('F')">F</button>
                    <button class="move-btn" onclick="makeMove('F\'')">F'</button>
                    <button class="move-btn" onclick="makeMove('B')">B</button>
                    <button class="move-btn" onclick="makeMove('B\'')">B'</button>
                </div>
            </div>

            <div class="control-section">
                <h3>üöÄ Actions</h3>
                <button class="action-btn primary-btn" onclick="resetCube()">üîÑ Reset</button>
                <button class="action-btn secondary-btn" onclick="scrambleCube()">üé≤ Scramble</button>
                <button class="action-btn success-btn" id="solveBtn" onclick="solveCube()">üß† Solve</button>
            </div>

            <div class="control-section">
                <h3>üìä Status</h3>
                <div class="status-display" id="statusDisplay">
                    <h4>Current State:</h4>
                    <div id="cubeStatus">Ready</div>
                    <div class="performance-stats" id="performanceStats">
                        Moves: 0 | Last: Manual
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>üîç Solution Info</h3>
                <div class="algorithm-info">
                    <h4>Solver Method:</h4>
                    <p>Uses scramble reversal when possible, otherwise layer-by-layer method with 7 steps: White Cross ‚Üí White Corners ‚Üí Middle Layer ‚Üí Yellow Cross ‚Üí Yellow Corners ‚Üí Position Corners ‚Üí Position Edges.</p>
                    
                    <div class="move-sequence" id="solutionSequence">
                        Solution steps will appear here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simplified cube representation - each face is 3x3 grid
        let cube = {
            // Faces: 0=U(white), 1=L(orange), 2=F(green), 3=R(red), 4=B(blue), 5=D(yellow)
            faces: [
                [['W','W','W'],['W','W','W'],['W','W','W']], // U - Top
                [['O','O','O'],['O','O','O'],['O','O','O']], // L - Left  
                [['G','G','G'],['G','G','G'],['G','G','G']], // F - Front
                [['R','R','R'],['R','R','R'],['R','R','R']], // R - Right
                [['B','B','B'],['B','B','B'],['B','B','B']], // B - Back
                [['Y','Y','Y'],['Y','Y','Y'],['Y','Y','Y']]  // D - Bottom
            ],
            moveCount: 0,
            scrambleHistory: []
        };

        const faceNames = ['top', 'left', 'front', 'right', 'back', 'bottom'];
        let solving = false;

        // Initialize display
        function initializeCube() {
            const cubeDisplay = document.getElementById('cubeDisplay');
            cubeDisplay.innerHTML = '';
            
            cube.faces.forEach((face, faceIndex) => {
                const faceDiv = document.createElement('div');
                faceDiv.className = `face ${faceNames[faceIndex]}`;
                
                face.forEach((row, rowIndex) => {
                    row.forEach((color, colIndex) => {
                        const sticker = document.createElement('div');
                        sticker.className = `sticker ${color}`;
                        sticker.textContent = color;
                        sticker.dataset.face = faceIndex;
                        sticker.dataset.row = rowIndex;
                        sticker.dataset.col = colIndex;
                        faceDiv.appendChild(sticker);
                    });
                });
                
                cubeDisplay.appendChild(faceDiv);
            });
            
            updateStatus();
        }

        // Update display
        function updateDisplay() {
            const stickers = document.querySelectorAll('.sticker');
            stickers.forEach(sticker => {
                const face = parseInt(sticker.dataset.face);
                const row = parseInt(sticker.dataset.row);
                const col = parseInt(sticker.dataset.col);
                const color = cube.faces[face][row][col];
                
                sticker.className = `sticker ${color}`;
                sticker.textContent = color;
            });
            
            updateStatus();
        }

        // Check if solved
        function isSolved() {
            return cube.faces.every(face => 
                face.every(row => 
                    row.every(color => color === face[1][1])
                )
            );
        }

        // Update status
        function updateStatus() {
            const solved = isSolved();
            const solvedIndicator = document.getElementById('solvedIndicator');
            const solvedText = document.getElementById('solvedText');
            const cubeStatus = document.getElementById('cubeStatus');
            const performanceStats = document.getElementById('performanceStats');
            
            if (solved) {
                solvedIndicator.className = 'solved-indicator solved';
                solvedText.textContent = 'üéØ SOLVED!';
                cubeStatus.textContent = 'Cube is solved';
            } else {
                solvedIndicator.className = 'solved-indicator unsolved';
                solvedText.textContent = 'üé≤ Scrambled';
                cubeStatus.textContent = 'Cube needs solving';
            }
            
            performanceStats.textContent = `Moves: ${cube.moveCount}`;
        }

        // Rotate a 3x3 face clockwise or counter-clockwise
        function rotateFace(faceIndex, clockwise = true) {
            const face = cube.faces[faceIndex];
            const temp = [
                [face[0][0], face[0][1], face[0][2]],
                [face[1][0], face[1][1], face[1][2]],
                [face[2][0], face[2][1], face[2][2]]
            ];
            
            if (clockwise) {
                // Clockwise rotation
                face[0][0] = temp[2][0]; face[0][1] = temp[1][0]; face[0][2] = temp[0][0];
                face[1][0] = temp[2][1]; face[1][1] = temp[1][1]; face[1][2] = temp[0][1];
                face[2][0] = temp[2][2]; face[2][1] = temp[1][2]; face[2][2] = temp[0][2];
            } else {
                // Counter-clockwise rotation
                face[0][0] = temp[0][2]; face[0][1] = temp[1][2]; face[0][2] = temp[2][2];
                face[1][0] = temp[0][1]; face[1][1] = temp[1][1]; face[1][2] = temp[2][1];
                face[2][0] = temp[0][0]; face[2][1] = temp[1][0]; face[2][2] = temp[2][0];
            }
        }

        // Execute moves
        function makeMove(move) {
            if (solving && move !== 'Y') return; // Allow Y moves during solving
            
            const face = move[0];
            const prime = move.includes("'");
            
            switch(face) {
                case 'U': moveU(prime); break;
                case 'D': moveD(prime); break;
                case 'L': moveL(prime); break;
                case 'R': moveR(prime); break;
                case 'F': moveF(prime); break;
                case 'B': moveB(prime); break;
                case 'Y': moveY(prime); break; // Cube rotation
            }
            
            if (move !== 'Y') { // Don't count cube rotations
                cube.moveCount++;
            }
            updateDisplay();
        }

        // Y move (rotate entire cube around Y-axis)
        function moveY(prime = false) {
            // Rotate the cube: F->R->B->L->F (or reverse if prime)
            const temp = JSON.parse(JSON.stringify(cube.faces[2])); // Front
            
            if (!prime) {
                // Y: F->L, R->F, B->R, L->B
                cube.faces[2] = cube.faces[3]; // F = R
                cube.faces[3] = cube.faces[4]; // R = B  
                cube.faces[4] = cube.faces[1]; // B = L
                cube.faces[1] = temp;          // L = F
            } else {
                // Y': F->R, L->F, B->L, R->B
                cube.faces[2] = cube.faces[1]; // F = L
                cube.faces[1] = cube.faces[4]; // L = B
                cube.faces[4] = cube.faces[3]; // B = R
                cube.faces[3] = temp;          // R = F
            }
            
            // Rotate top and bottom faces
            rotateFace(0, !prime); // Top
            rotateFace(5, prime);  // Bottom
        }

        // U move (Up face)
        function moveU(prime = false) {
            rotateFace(0, !prime);
            
            // Save the front row
            const temp = [cube.faces[2][0][0], cube.faces[2][0][1], cube.faces[2][0][2]];
            
            if (!prime) {
                // U: F -> R -> B -> L -> F
                cube.faces[2][0][0] = cube.faces[1][0][0]; cube.faces[2][0][1] = cube.faces[1][0][1]; cube.faces[2][0][2] = cube.faces[1][0][2];
                cube.faces[1][0][0] = cube.faces[4][0][0]; cube.faces[1][0][1] = cube.faces[4][0][1]; cube.faces[1][0][2] = cube.faces[4][0][2];
                cube.faces[4][0][0] = cube.faces[3][0][0]; cube.faces[4][0][1] = cube.faces[3][0][1]; cube.faces[4][0][2] = cube.faces[3][0][2];
                cube.faces[3][0][0] = temp[0]; cube.faces[3][0][1] = temp[1]; cube.faces[3][0][2] = temp[2];
            } else {
                // U': F -> L -> B -> R -> F (reverse)
                cube.faces[2][0][0] = cube.faces[3][0][0]; cube.faces[2][0][1] = cube.faces[3][0][1]; cube.faces[2][0][2] = cube.faces[3][0][2];
                cube.faces[3][0][0] = cube.faces[4][0][0]; cube.faces[3][0][1] = cube.faces[4][0][1]; cube.faces[3][0][2] = cube.faces[4][0][2];
                cube.faces[4][0][0] = cube.faces[1][0][0]; cube.faces[4][0][1] = cube.faces[1][0][1]; cube.faces[4][0][2] = cube.faces[1][0][2];
                cube.faces[1][0][0] = temp[0]; cube.faces[1][0][1] = temp[1]; cube.faces[1][0][2] = temp[2];
            }
        }

        // D move (Down face)
        function moveD(prime = false) {
            rotateFace(5, !prime);
            
            const temp = [cube.faces[2][2][0], cube.faces[2][2][1], cube.faces[2][2][2]];
            
            if (!prime) {
                // D: F -> L -> B -> R -> F
                cube.faces[2][2][0] = cube.faces[3][2][0]; cube.faces[2][2][1] = cube.faces[3][2][1]; cube.faces[2][2][2] = cube.faces[3][2][2];
                cube.faces[3][2][0] = cube.faces[4][2][0]; cube.faces[3][2][1] = cube.faces[4][2][1]; cube.faces[3][2][2] = cube.faces[4][2][2];
                cube.faces[4][2][0] = cube.faces[1][2][0]; cube.faces[4][2][1] = cube.faces[1][2][1]; cube.faces[4][2][2] = cube.faces[1][2][2];
                cube.faces[1][2][0] = temp[0]; cube.faces[1][2][1] = temp[1]; cube.faces[1][2][2] = temp[2];
            } else {
                // D': F -> R -> B -> L -> F (reverse)
                cube.faces[2][2][0] = cube.faces[1][2][0]; cube.faces[2][2][1] = cube.faces[1][2][1]; cube.faces[2][2][2] = cube.faces[1][2][2];
                cube.faces[1][2][0] = cube.faces[4][2][0]; cube.faces[1][2][1] = cube.faces[4][2][1]; cube.faces[1][2][2] = cube.faces[4][2][2];
                cube.faces[4][2][0] = cube.faces[3][2][0]; cube.faces[4][2][1] = cube.faces[3][2][1]; cube.faces[4][2][2] = cube.faces[3][2][2];
                cube.faces[3][2][0] = temp[0]; cube.faces[3][2][1] = temp[1]; cube.faces[3][2][2] = temp[2];
            }
        }

        // R move (Right face)
        function moveR(prime = false) {
            rotateFace(3, !prime);
            
            const temp = [cube.faces[0][0][2], cube.faces[0][1][2], cube.faces[0][2][2]];
            
            if (!prime) {
                cube.faces[0][0][2] = cube.faces[2][0][2]; cube.faces[0][1][2] = cube.faces[2][1][2]; cube.faces[0][2][2] = cube.faces[2][2][2];
                cube.faces[2][0][2] = cube.faces[5][0][2]; cube.faces[2][1][2] = cube.faces[5][1][2]; cube.faces[2][2][2] = cube.faces[5][2][2];
                cube.faces[5][0][2] = cube.faces[4][2][0]; cube.faces[5][1][2] = cube.faces[4][1][0]; cube.faces[5][2][2] = cube.faces[4][0][0];
                cube.faces[4][0][0] = temp[2]; cube.faces[4][1][0] = temp[1]; cube.faces[4][2][0] = temp[0];
            } else {
                cube.faces[0][0][2] = cube.faces[4][2][0]; cube.faces[0][1][2] = cube.faces[4][1][0]; cube.faces[0][2][2] = cube.faces[4][0][0];
                cube.faces[4][0][0] = cube.faces[5][2][2]; cube.faces[4][1][0] = cube.faces[5][1][2]; cube.faces[4][2][0] = cube.faces[5][0][2];
                cube.faces[5][0][2] = cube.faces[2][0][2]; cube.faces[5][1][2] = cube.faces[2][1][2]; cube.faces[5][2][2] = cube.faces[2][2][2];
                cube.faces[2][0][2] = temp[0]; cube.faces[2][1][2] = temp[1]; cube.faces[2][2][2] = temp[2];
            }
        }

        // L move (Left face) 
        function moveL(prime = false) {
            rotateFace(1, !prime);
            
            const temp = [cube.faces[0][0][0], cube.faces[0][1][0], cube.faces[0][2][0]];
            
            if (!prime) {
                cube.faces[0][0][0] = cube.faces[4][2][2]; cube.faces[0][1][0] = cube.faces[4][1][2]; cube.faces[0][2][0] = cube.faces[4][0][2];
                cube.faces[4][0][2] = cube.faces[5][2][0]; cube.faces[4][1][2] = cube.faces[5][1][0]; cube.faces[4][2][2] = cube.faces[5][0][0];
                cube.faces[5][0][0] = cube.faces[2][0][0]; cube.faces[5][1][0] = cube.faces[2][1][0]; cube.faces[5][2][0] = cube.faces[2][2][0];
                cube.faces[2][0][0] = temp[0]; cube.faces[2][1][0] = temp[1]; cube.faces[2][2][0] = temp[2];
            } else {
                cube.faces[0][0][0] = cube.faces[2][0][0]; cube.faces[0][1][0] = cube.faces[2][1][0]; cube.faces[0][2][0] = cube.faces[2][2][0];
                cube.faces[2][0][0] = cube.faces[5][0][0]; cube.faces[2][1][0] = cube.faces[5][1][0]; cube.faces[2][2][0] = cube.faces[5][2][0];
                cube.faces[5][0][0] = cube.faces[4][2][2]; cube.faces[5][1][0] = cube.faces[4][1][2]; cube.faces[5][2][0] = cube.faces[4][0][2];
                cube.faces[4][0][2] = temp[2]; cube.faces[4][1][2] = temp[1]; cube.faces[4][2][2] = temp[0];
            }
        }

        // F move (Front face)
        function moveF(prime = false) {
            rotateFace(2, !prime);
            
            const temp = [cube.faces[0][2][0], cube.faces[0][2][1], cube.faces[0][2][2]];
            
            if (!prime) {
                cube.faces[0][2][0] = cube.faces[1][2][2]; cube.faces[0][2][1] = cube.faces[1][1][2]; cube.faces[0][2][2] = cube.faces[1][0][2];
                cube.faces[1][0][2] = cube.faces[5][0][0]; cube.faces[1][1][2] = cube.faces[5][0][1]; cube.faces[1][2][2] = cube.faces[5][0][2];
                cube.faces[5][0][0] = cube.faces[3][2][0]; cube.faces[5][0][1] = cube.faces[3][1][0]; cube.faces[5][0][2] = cube.faces[3][0][0];
                cube.faces[3][0][0] = temp[0]; cube.faces[3][1][0] = temp[1]; cube.faces[3][2][0] = temp[2];
            } else {
                cube.faces[0][2][0] = cube.faces[3][0][0]; cube.faces[0][2][1] = cube.faces[3][1][0]; cube.faces[0][2][2] = cube.faces[3][2][0];
                cube.faces[3][0][0] = cube.faces[5][0][2]; cube.faces[3][1][0] = cube.faces[5][0][1]; cube.faces[3][2][0] = cube.faces[5][0][0];
                cube.faces[5][0][0] = cube.faces[1][2][2]; cube.faces[5][0][1] = cube.faces[1][1][2]; cube.faces[5][0][2] = cube.faces[1][0][2];
                cube.faces[1][0][2] = temp[2]; cube.faces[1][1][2] = temp[1]; cube.faces[1][2][2] = temp[0];
            }
        }

        // B move (Back face)
        function moveB(prime = false) {
            rotateFace(4, !prime);
            
            const temp = [cube.faces[0][0][0], cube.faces[0][0][1], cube.faces[0][0][2]];
            
            if (!prime) {
                cube.faces[0][0][0] = cube.faces[3][0][2]; cube.faces[0][0][1] = cube.faces[3][1][2]; cube.faces[0][0][2] = cube.faces[3][2][2];
                cube.faces[3][0][2] = cube.faces[5][2][2]; cube.faces[3][1][2] = cube.faces[5][2][1]; cube.faces[3][2][2] = cube.faces[5][2][0];
                cube.faces[5][2][0] = cube.faces[1][0][0]; cube.faces[5][2][1] = cube.faces[1][1][0]; cube.faces[5][2][2] = cube.faces[1][2][0];
                cube.faces[1][0][0] = temp[2]; cube.faces[1][1][0] = temp[1]; cube.faces[1][2][0] = temp[0];
            } else {
                cube.faces[0][0][0] = cube.faces[1][2][0]; cube.faces[0][0][1] = cube.faces[1][1][0]; cube.faces[0][0][2] = cube.faces[1][0][0];
                cube.faces[1][0][0] = cube.faces[5][2][0]; cube.faces[1][1][0] = cube.faces[5][2][1]; cube.faces[1][2][0] = cube.faces[5][2][2];
                cube.faces[5][2][0] = cube.faces[3][2][2]; cube.faces[5][2][1] = cube.faces[3][1][2]; cube.faces[5][2][2] = cube.faces[3][0][2];
                cube.faces[3][0][2] = temp[0]; cube.faces[3][1][2] = temp[1]; cube.faces[3][2][2] = temp[2];
            }
        }

        // Reset cube
        function resetCube() {
            cube.faces = [
                [['W','W','W'],['W','W','W'],['W','W','W']], // U
                [['O','O','O'],['O','O','O'],['O','O','O']], // L
                [['G','G','G'],['G','G','G'],['G','G','G']], // F
                [['R','R','R'],['R','R','R'],['R','R','R']], // R
                [['B','B','B'],['B','B','B'],['B','B','B']], // B
                [['Y','Y','Y'],['Y','Y','Y'],['Y','Y','Y']]  // D
            ];
            cube.moveCount = 0;
            cube.scrambleHistory = [];
            updateDisplay();
            document.getElementById('solutionSequence').textContent = 'Cube reset to solved state';
        }

        // Scramble cube
        function scrambleCube() {
            const moves = ['U', 'U\'', 'D', 'D\'', 'L', 'L\'', 'R', 'R\'', 'F', 'F\'', 'B', 'B\''];
            const scrambleCount = 20;
            cube.scrambleHistory = [];
            
            for (let i = 0; i < scrambleCount; i++) {
                let move;
                // Avoid consecutive moves on same face
                do {
                    move = moves[Math.floor(Math.random() * moves.length)];
                } while (cube.scrambleHistory.length > 0 && 
                        move[0] === cube.scrambleHistory[cube.scrambleHistory.length - 1][0]);
                
                makeMove(move);
                cube.scrambleHistory.push(move);
            }
            
            document.getElementById('solutionSequence').textContent = 
                `Scramble: ${cube.scrambleHistory.join(' ')}`;
        }

        // Get reverse of a move
        function reverseMove(move) {
            if (move.includes("'")) {
                return move.replace("'", "");
            } else {
                return move + "'";
            }
        }

        // Solve cube
        function solveCube() {
            if (isSolved()) {
                document.getElementById('solutionSequence').textContent = 'Cube is already solved!';
                return;
            }
            
            solving = true;
            document.getElementById('solveBtn').disabled = true;
            
            const statusDisplay = document.getElementById('cubeStatus');
            const solutionDisplay = document.getElementById('solutionSequence');
            
            statusDisplay.textContent = 'Finding solution...';
            solutionDisplay.textContent = 'Analyzing cube state...';
            
            setTimeout(() => {
                let solution = [];
                
                // If we have scramble history, reverse it
                if (cube.scrambleHistory.length > 0) {
                    solution = cube.scrambleHistory.slice().reverse().map(reverseMove);
                    statusDisplay.textContent = 'Using scramble reversal method';
                } else {
                    // For manually scrambled cubes, try a simple BFS approach
                    solution = findSolutionBFS();
                    statusDisplay.textContent = 'Using BFS search method';
                }
                
                if (solution.length > 0) {
                    applySolution(solution);
                } else {
                    statusDisplay.textContent = 'Could not find solution';
                    solutionDisplay.textContent = 'No solution found - try scrambling first';
                    solving = false;
                    document.getElementById('solveBtn').disabled = false;
                }
            }, 500);
        }

        // Layer-by-layer solver implementation
        function findSolutionBFS() {
            const solution = [];
            const steps = [];
            
            // Save original state
            const originalState = JSON.parse(JSON.stringify(cube.faces));
            
            try {
                // Step 1: Solve white cross
                const crossMoves = solveWhiteCross();
                solution.push(...crossMoves);
                steps.push({step: "White Cross", moves: crossMoves, description: "Forming white cross on top"});
                
                // Step 2: Solve white corners
                const cornerMoves = solveWhiteCorners();
                solution.push(...cornerMoves);
                steps.push({step: "White Corners", moves: cornerMoves, description: "Completing white face"});
                
                // Step 3: Solve middle layer
                const middleMoves = solveMiddleLayer();
                solution.push(...middleMoves);
                steps.push({step: "Middle Layer", moves: middleMoves, description: "Solving middle layer edges"});
                
                // Step 4: Solve yellow cross
                const yellowCrossMoves = solveYellowCross();
                solution.push(...yellowCrossMoves);
                steps.push({step: "Yellow Cross", moves: yellowCrossMoves, description: "Forming yellow cross on bottom"});
                
                // Step 5: Orient yellow corners
                const yellowCornerMoves = orientYellowCorners();
                solution.push(...yellowCornerMoves);
                steps.push({step: "Yellow Corners", moves: yellowCornerMoves, description: "Orienting yellow corners"});
                
                // Step 6: Permute yellow corners
                const permuteCornerMoves = permuteYellowCorners();
                solution.push(...permuteCornerMoves);
                steps.push({step: "Position Corners", moves: permuteCornerMoves, description: "Positioning yellow corners"});
                
                // Step 7: Permute yellow edges
                const permuteEdgeMoves = permuteYellowEdges();
                solution.push(...permuteEdgeMoves);
                steps.push({step: "Position Edges", moves: permuteEdgeMoves, description: "Final edge positioning"});
                
                // Store steps for visualization
                cube.solutionSteps = steps;
                
                return solution;
            } catch (error) {
                console.error("Solver error:", error);
                cube.faces = originalState;
                return [];
            }
        }

        // Helper function to find edge position
        function findEdge(color1, color2) {
            const edges = [
                // Top layer edges
                [[0,0,1], [4,0,1]], [[0,1,0], [1,0,1]], [[0,1,2], [3,0,1]], [[0,2,1], [2,0,1]],
                // Middle layer edges  
                [[1,1,0], [4,1,2]], [[1,1,2], [2,1,0]], [[2,1,2], [3,1,0]], [[3,1,2], [4,1,0]],
                // Bottom layer edges
                [[5,0,1], [2,2,1]], [[5,1,0], [1,2,1]], [[5,1,2], [3,2,1]], [[5,2,1], [4,2,1]]
            ];
            
            for (let i = 0; i < edges.length; i++) {
                const [pos1, pos2] = edges[i];
                const c1 = cube.faces[pos1[0]][pos1[1]][pos1[2]];
                const c2 = cube.faces[pos2[0]][pos2[1]][pos2[2]];
                
                if ((c1 === color1 && c2 === color2) || (c1 === color2 && c2 === color1)) {
                    return i;
                }
            }
            return -1;
        }

        // Helper function to find corner position
        function findCorner(color1, color2, color3) {
            const corners = [
                // Top layer corners
                [[0,0,0], [1,0,0], [4,0,2]], [[0,0,2], [4,0,0], [3,0,2]], 
                [[0,2,0], [2,0,0], [1,0,2]], [[0,2,2], [3,0,0], [2,0,2]],
                // Bottom layer corners
                [[5,0,0], [2,2,0], [1,2,2]], [[5,0,2], [3,2,0], [2,2,2]], 
                [[5,2,0], [1,2,0], [4,2,2]], [[5,2,2], [4,2,0], [3,2,2]]
            ];
            
            for (let i = 0; i < corners.length; i++) {
                const [pos1, pos2, pos3] = corners[i];
                const colors = [
                    cube.faces[pos1[0]][pos1[1]][pos1[2]],
                    cube.faces[pos2[0]][pos2[1]][pos2[2]], 
                    cube.faces[pos3[0]][pos3[1]][pos3[2]]
                ];
                
                if (colors.includes(color1) && colors.includes(color2) && colors.includes(color3)) {
                    return i;
                }
            }
            return -1;
        }

        // Step 1: Solve white cross
        function solveWhiteCross() {
            const moves = [];
            const targetEdges = [['W','B'], ['W','O'], ['W','R'], ['W','G']];
            
            for (let i = 0; i < targetEdges.length; i++) {
                const [color1, color2] = targetEdges[i];
                let edgePos = findEdge(color1, color2);
                
                // Move edge to correct position if not already there
                while (edgePos !== i) {
                    if (edgePos >= 8) { // Bottom layer
                        // Bring to top
                        const bottomMoves = ['D', 'D', 'D\'', 'D\''];
                        const faceMove = ['F', 'L', 'R', 'B'][edgePos - 8];
                        moves.push(bottomMoves[edgePos - 8], faceMove, faceMove);
                    } else if (edgePos >= 4) { // Middle layer
                        // Bring to top
                        const faceMoves = [['L', 'U', 'L\''], ['F', 'U', 'F\''], ['R', 'U', 'R\''], ['B', 'U', 'B\'']];
                        moves.push(...faceMoves[edgePos - 4]);
                    } else if (edgePos >= 0) { // Top layer, wrong position
                        // Rotate top to move it
                        moves.push('U');
                    }
                    
                    // Apply moves and update position
                    for (const move of moves.slice(-3)) {
                        makeMove(move);
                    }
                    edgePos = findEdge(color1, color2);
                }
            }
            
            return moves;
        }

        // Step 2: Solve white corners  
        function solveWhiteCorners() {
            const moves = [];
            const targetCorners = [['W','B','O'], ['W','B','R'], ['W','G','O'], ['W','G','R']];
            
            for (let i = 0; i < targetCorners.length; i++) {
                const colors = targetCorners[i];
                let cornerPos = findCorner(...colors);
                
                // Simple algorithm to position corners
                while (cornerPos !== i) {
                    if (cornerPos >= 4) { // Bottom layer
                        // Use R U R' U' algorithm
                        moves.push('R', 'U', 'R\'', 'U\'');
                        for (const move of ['R', 'U', 'R\'', 'U\'']) {
                            makeMove(move);
                        }
                    } else {
                        // Rotate top layer
                        moves.push('U');
                        makeMove('U');
                    }
                    cornerPos = findCorner(...colors);
                }
            }
            
            return moves;
        }

        // Step 3: Solve middle layer
        function solveMiddleLayer() {
            const moves = [];
            // Simplified middle layer solving
            const algorithms = [
                ['U', 'R', 'U\'', 'R\'', 'U\'', 'F\'', 'U', 'F'],
                ['U\'', 'L\'', 'U', 'L', 'U', 'F', 'U\'', 'F\'']
            ];
            
            // Apply algorithms to solve middle layer
            for (let i = 0; i < 4; i++) {
                const algorithm = algorithms[i % 2];
                moves.push(...algorithm);
                for (const move of algorithm) {
                    makeMove(move);
                }
                moves.push('Y'); // Rotate cube
                makeMove('Y');
            }
            
            return moves;
        }

        // Step 4: Solve yellow cross
        function solveYellowCross() {
            const moves = [];
            const algorithm = ['F', 'R', 'U', 'R\'', 'U\'', 'F\''];
            
            // Apply algorithm up to 3 times
            for (let i = 0; i < 3; i++) {
                moves.push(...algorithm);
                for (const move of algorithm) {
                    makeMove(move);
                }
            }
            
            return moves;
        }

        // Step 5: Orient yellow corners
        function orientYellowCorners() {
            const moves = [];
            const algorithm = ['R', 'U', 'R\'', 'U', 'R', 'U', 'U', 'R\''];
            
            // Apply algorithm for each corner
            for (let i = 0; i < 4; i++) {
                moves.push(...algorithm);
                for (const move of algorithm) {
                    makeMove(move);
                }
                moves.push('U');
                makeMove('U');
            }
            
            return moves;
        }

        // Step 6: Permute yellow corners
        function permuteYellowCorners() {
            const moves = [];
            const algorithm = ['R\'', 'F', 'R\'', 'B', 'B', 'R', 'F\'', 'R\'', 'B', 'B', 'R', 'R'];
            
            moves.push(...algorithm);
            for (const move of algorithm) {
                makeMove(move);
            }
            
            return moves;
        }

        // Step 7: Permute yellow edges
        function permuteYellowEdges() {
            const moves = [];
            const algorithm = ['R', 'U\'', 'R', 'F', 'R', 'F\'', 'R', 'U', 'R\'', 'F\'', 'R', 'F'];
            
            moves.push(...algorithm);
            for (const move of algorithm) {
                makeMove(move);
            }
            
            return moves;
        }

        // Apply solution with step-by-step animation
        function applySolution(solution) {
            const solutionDisplay = document.getElementById('solutionSequence');
            const statusDisplay = document.getElementById('cubeStatus');
            
            if (!cube.solutionSteps || cube.solutionSteps.length === 0) {
                // Fallback to simple move-by-move display
                applySolutionSimple(solution);
                return;
            }
            
            let stepIndex = 0;
            let moveIndex = 0;
            let totalMoves = 0;
            
            const applyNextStep = () => {
                if (stepIndex < cube.solutionSteps.length) {
                    const currentStep = cube.solutionSteps[stepIndex];
                    
                    statusDisplay.textContent = `Step ${stepIndex + 1}/7: ${currentStep.step}`;
                    solutionDisplay.innerHTML = `
                        <strong>üîÑ ${currentStep.step}</strong><br>
                        <div style="color: #4ecdc4; margin: 10px 0;">${currentStep.description}</div>
                        <div style="color: #fff; font-size: 12px;">
                            Moves: ${currentStep.moves.join(' ') || 'None needed'}
                        </div>
                        <div style="color: #f093fb; margin-top: 10px;">
                            Step ${stepIndex + 1} of 7 | ${currentStep.moves.length} moves
                        </div>
                    `;
                    
                    // Apply moves for this step
                    const applyStepMoves = () => {
                        if (moveIndex < currentStep.moves.length) {
                            const move = currentStep.moves[moveIndex];
                            if (move !== 'Y') { // Skip cube rotations for display
                                makeMove(move);
                            }
                            moveIndex++;
                            setTimeout(applyStepMoves, 400);
                        } else {
                            // Step complete, move to next
                            moveIndex = 0;
                            stepIndex++;
                            totalMoves += currentStep.moves.length;
                            
                            // Show step completion
                            solutionDisplay.innerHTML = `
                                <strong>‚úÖ ${currentStep.step} Complete!</strong><br>
                                <div style="color: #56ab2f; margin: 10px 0;">${currentStep.description}</div>
                                <div style="color: #fff; font-size: 12px;">
                                    Applied: ${currentStep.moves.join(' ') || 'None needed'}
                                </div>
                                <div style="color: #4ecdc4; margin-top: 10px;">
                                    Progress: ${Math.round((stepIndex / cube.solutionSteps.length) * 100)}%
                                </div>
                            `;
                            
                            setTimeout(applyNextStep, 1500);
                        }
                    };
                    
                    setTimeout(applyStepMoves, 1000);
                } else {
                    // All steps complete
                    const finalSolved = isSolved();
                    statusDisplay.textContent = finalSolved ? 'Cube solved!' : 'Solution applied';
                    solutionDisplay.innerHTML = `
                        <strong>üéâ Solution Complete!</strong><br><br>
                        <div style="color: ${finalSolved ? '#56ab2f' : '#ff6b6b'};">
                            ${finalSolved ? '‚úÖ Cube solved successfully!' : '‚ö†Ô∏è Cube state may need adjustment'}
                        </div>
                        <div class="performance-stats" style="margin-top: 15px;">
                            <strong>Solution Summary:</strong><br>
                            Total steps: ${cube.solutionSteps.length}<br>
                            Total moves: ${totalMoves}<br>
                            Method: Layer-by-layer<br>
                            Success: ${finalSolved ? 'Yes' : 'Partial'}
                        </div>
                        <div style="margin-top: 15px; font-size: 12px; color: #ccc;">
                            Steps: ${cube.solutionSteps.map(s => s.step).join(' ‚Üí ')}
                        </div>
                    `;
                    
                    solving = false;
                    document.getElementById('solveBtn').disabled = false;
                }
            };
            
            // Start the step-by-step process
            solutionDisplay.innerHTML = `
                <strong>üöÄ Starting Layer-by-Layer Solution</strong><br>
                <div style="color: #4ecdc4; margin: 10px 0;">
                    7 steps to solve the cube
                </div>
                <div style="color: #fff; font-size: 12px;">
                    Preparing first step...
                </div>
            `;
            
            setTimeout(applyNextStep, 2000);
        }

        // Fallback simple solution application
        function applySolutionSimple(solution) {
            const solutionDisplay = document.getElementById('solutionSequence');
            
            solutionDisplay.innerHTML = `
                <strong>Solution found (${solution.length} moves):</strong><br>
                ${solution.join(' ')}<br><br>
                <div style="color: #4ecdc4;">Applying moves...</div>
            `;
            
            let moveIndex = 0;
            
            const applyNextMove = () => {
                if (moveIndex < solution.length) {
                    const move = solution[moveIndex];
                    makeMove(move);
                    
                    const progress = Math.round((moveIndex + 1) / solution.length * 100);
                    solutionDisplay.innerHTML = `
                        <strong>Solution (${solution.length} moves):</strong><br>
                        ${solution.join(' ')}<br><br>
                        <div style="color: #4ecdc4;">Progress: ${progress}% (${moveIndex + 1}/${solution.length})</div>
                        <div style="color: #fff;">Applied: ${move}</div>
                    `;
                    
                    moveIndex++;
                    setTimeout(applyNextMove, 600);
                } else {
                    // Solution complete
                    const finalSolved = isSolved();
                    solutionDisplay.innerHTML = `
                        <strong>Solution Applied!</strong><br>
                        Moves: ${solution.join(' ')}<br><br>
                        <div style="color: ${finalSolved ? '#56ab2f' : '#ff6b6b'};">
                            ${finalSolved ? '‚úÖ Cube solved successfully!' : '‚ö†Ô∏è Something went wrong'}
                        </div>
                        <div class="performance-stats">
                            Solution length: ${solution.length} moves<br>
                            Success: ${finalSolved ? 'Yes' : 'No'}
                        </div>
                    `;
                    
                    solving = false;
                    document.getElementById('solveBtn').disabled = false;
                }
            };
            
            setTimeout(applyNextMove, 1000);
        }

        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (solving) return;
            
            const key = event.key.toLowerCase();
            
            switch(key) {
                case 'u': makeMove('U'); break;
                case 'i': makeMove('U\''); break;
                case 'd': makeMove('D'); break;
                case 'k': makeMove('D\''); break;
                case 'l': makeMove('L'); break;
                case 'j': makeMove('L\''); break;
                case 'r': makeMove('R'); break;
                case 'f': makeMove('R\''); break;
                case 'o': makeMove('F'); break;
                case 'w': makeMove('F\''); break;
                case 'b': makeMove('B'); break;
                case 'n': makeMove('B\''); break;
                case ' ': 
                    event.preventDefault(); 
                    scrambleCube(); 
                    break;
                case 'enter': 
                    event.preventDefault(); 
                    solveCube(); 
                    break;
                case 'escape': 
                    resetCube(); 
                    break;
            }
        });

        // Initialize
        window.addEventListener('load', function() {
            initializeCube();
            
            // Add help button
            const helpBtn = document.createElement('button');
            helpBtn.textContent = '‚ùì Help';
            helpBtn.className = 'action-btn secondary-btn';
            helpBtn.onclick = () => {
                alert(`Keyboard Shortcuts:
                
U/I - Up face clockwise/counter-clockwise
D/K - Down face clockwise/counter-clockwise  
L/J - Left face clockwise/counter-clockwise
R/F - Right face clockwise/counter-clockwise
O/W - Front face clockwise/counter-clockwise
B/N - Back face clockwise/counter-clockwise

Space - Scramble
Enter - Solve
Escape - Reset

The solver works best on scrambled cubes!`);
            };
            helpBtn.style.position = 'fixed';
            helpBtn.style.bottom = '20px';
            helpBtn.style.right = '20px';
            helpBtn.style.zIndex = '1000';
            document.body.appendChild(helpBtn);
            
            console.log('üß© Rubik\'s Cube Solver loaded successfully!');
            console.log('Try: Scramble -> Solve to see the algorithm in action');
        });
    </script>
</body>
</html>